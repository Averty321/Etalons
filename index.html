<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Генератор Лабиринтов</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(to bottom, #2c3e50, #4ca1af);
            color: white;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            user-select: none;
        }
        
        #game-container {
            position: relative;
            width: 95vmin;
            height: 95vmin;
            max-width: 600px;
            max-height: 600px;
            margin: 10px;
        }
        
        #maze-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #1a1a2e;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(26, 26, 46, 0.9);
            border-radius: 8px;
            z-index: 10;
            text-align: center;
            padding: 20px;
        }
        
        .hidden {
            display: none !important;
        }
        
        h1 {
            font-size: 2.2rem;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            color: #ffcc00;
        }
        
        p {
            margin-bottom: 20px;
            font-size: 1.1rem;
            line-height: 1.4;
        }
        
        button {
            background: linear-gradient(to bottom, #ff7e5f, #feb47b);
            border: none;
            border-radius: 50px;
            color: white;
            padding: 15px 30px;
            font-size: 1.2rem;
            margin: 10px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: transform 0.1s, box-shadow 0.1s;
        }
        
        button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 10px;
            z-index: 5;
            font-size: 1rem;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 20px;
            z-index: 5;
        }
        
        .control-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        #level-up {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 15;
            animation: fadeInOut 3s forwards;
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; display: none; }
        }
        
        #instructions {
            position: absolute;
            bottom: 100px;
            text-align: center;
            width: 100%;
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .difficulty-buttons {
            display: flex;
            flex-direction: column;
            width: 80%;
            max-width: 300px;
        }
        
        .difficulty-buttons button {
            margin: 8px 0;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="maze-canvas"></canvas>
        
        <div id="stats">
            Уровень: <span id="level">1</span> | 
            Время: <span id="time">0</span>с
        </div>
        
        <div id="controls">
            <div class="control-btn" id="up">↑</div>
            <div class="control-btn" id="left">←</div>
            <div class="control-btn" id="right">→</div>
            <div class="control-btn" id="down">↓</div>
        </div>
        
        <div id="start-screen" class="screen">
            <h1>Генератор Лабиринтов</h1>
            <p>Найдите выход из случайно сгенерированного лабиринта! Управляйте с помощью кнопок или свайпов.</p>
            <div class="difficulty-buttons">
                <button id="easy-btn">Лёгкий уровень</button>
                <button id="medium-btn">Средний уровень</button>
                <button id="hard-btn">Сложный уровень</button>
            </div>
        </div>
        
        <div id="level-complete-screen" class="screen hidden">
            <h1>Уровень пройден!</h1>
            <p>Вы нашли выход за <span id="complete-time">0</span> секунд</p>
            <button id="next-level-btn">Следующий уровень</button>
            <button id="menu-btn">В меню</button>
        </div>
        
        <div id="instructions">
            Свайпайте для движения или используйте кнопки
        </div>
    </div>

    <script>
        // Конфигурация игры
        const config = {
            easy: { cellSize: 40, mazeSize: 11 },
            medium: { cellSize: 30, mazeSize: 15 },
            hard: { cellSize: 20, mazeSize: 21 }
        };
        
        // Состояние игры
        let canvas, ctx;
        let maze = [];
        let player = { x: 1, y: 1 };
        let exit = { x: 0, y: 0 };
        let currentLevel = 1;
        let gameTime = 0;
        let timerInterval;
        let currentDifficulty = 'medium';
        let cellSize, mazeSize;
        let touchStartX, touchStartY;
        
        // Инициализация игры
        function init() {
            canvas = document.getElementById('maze-canvas');
            ctx = canvas.getContext('2d');
            
            // Установка сложности
            document.getElementById('easy-btn').addEventListener('click', () => setDifficulty('easy'));
            document.getElementById('medium-btn').addEventListener('click', () => setDifficulty('medium'));
            document.getElementById('hard-btn').addEventListener('click', () => setDifficulty('hard'));
            
            // Кнопки управления
            document.getElementById('up').addEventListener('touchstart', () => movePlayer(0, -1));
            document.getElementById('down').addEventListener('touchstart', () => movePlayer(0, 1));
            document.getElementById('left').addEventListener('touchstart', () => movePlayer(-1, 0));
            document.getElementById('right').addEventListener('touchstart', () => movePlayer(1, 0));
            
            // Кнопки меню
            document.getElementById('next-level-btn').addEventListener('click', nextLevel);
            document.getElementById('menu-btn').addEventListener('click', showMenu);
            
            // Обработка свайпов
            canvas.addEventListener('touchstart', handleTouchStart, false);
            canvas.addEventListener('touchmove', handleTouchMove, false);
            
            // Установка размера canvas
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        }
        
        function setDifficulty(difficulty) {
            currentDifficulty = difficulty;
            cellSize = config[difficulty].cellSize;
            mazeSize = config[difficulty].mazeSize;
            startGame();
        }
        
        function resizeCanvas() {
            // Подстраиваем размер canvas под контейнер
            const container = document.getElementById('game-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            // Если игра активна, перерисовываем лабиринт
            if (maze.length > 0) {
                drawMaze();
            }
        }
        
        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('level-complete-screen').classList.add('hidden');
            
            generateMaze();
            drawMaze();
            
            // Сброс и запуск таймера
            gameTime = 0;
            document.getElementById('time').textContent = gameTime;
            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                gameTime++;
                document.getElementById('time').textContent = gameTime;
            }, 1000);
            
            // Обновление статистики
            document.getElementById('level').textContent = currentLevel;
        }
        
        function generateMaze() {
            // Инициализация матрицы лабиринта
            maze = [];
            for (let y = 0; y < mazeSize; y++) {
                maze[y] = [];
                for (let x = 0; x < mazeSize; x++) {
                    maze[y][x] = 1; // 1 = стена, 0 = проход
                }
            }
            
            // Начальная позиция игрока
            player = { x: 1, y: 1 };
            maze[player.y][player.x] = 0;
            
            // Рекурсивное создание лабиринта
            carvePath(1, 1);
            
            // Убедимся, что есть выход
            createExit();
        }
        
        function carvePath(x, y) {
            // Направления: вверх, вправо, вниз, влево
            const directions = [
                [0, -2], [2, 0], [0, 2], [-2, 0]
            ];
            
            // Случайным образом перемешиваем направления
            shuffleArray(directions);
            
            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                
                // Если новая позиция внутри лабиринта и является стеной
                if (nx > 0 && nx < mazeSize - 1 && ny > 0 && ny < mazeSize - 1 && maze[ny][nx] === 1) {
                    // Убираем стену между текущей и новой ячейкой
                    maze[y + dy/2][x + dx/2] = 0;
                    maze[ny][nx] = 0;
                    
                    // Продолжаем рекурсивно
                    carvePath(nx, ny);
                }
            }
        }
        
        function createExit() {
            // Создаем выход в одной из границ лабиринта
            const side = Math.floor(Math.random() * 4); // 0: верх, 1: право, 2: низ, 3: лево
            
            switch (side) {
                case 0: // Верх
                    exit = { x: Math.floor(Math.random() * (mazeSize - 2)) + 1, y: 0 };
                    break;
                case 1: // Право
                    exit = { x: mazeSize - 1, y: Math.floor(Math.random() * (mazeSize - 2)) + 1 };
                    break;
                case 2: // Низ
                    exit = { x: Math.floor(Math.random() * (mazeSize - 2)) + 1, y: mazeSize - 1 };
                    break;
                case 3: // Лево
                    exit = { x: 0, y: Math.floor(Math.random() * (mazeSize - 2)) + 1 };
                    break;
            }
            
            // Убедимся, что выход соединен с лабиринтом
            if (exit.x === 0) maze[exit.y][exit.x + 1] = 0;
            else if (exit.x === mazeSize - 1) maze[exit.y][exit.x - 1] = 0;
            else if (exit.y === 0) maze[exit.y + 1][exit.x] = 0;
            else if (exit.y === mazeSize - 1) maze[exit.y - 1][exit.x] = 0;
        }
        
        function drawMaze() {
            const width = canvas.width;
            const height = canvas.height;
            const cellWidth = width / mazeSize;
            const cellHeight = height / mazeSize;
            
            // Очистка canvas
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, width, height);
            
            // Рисуем стены
            ctx.fillStyle = '#4cc9f0';
            for (let y = 0; y < mazeSize; y++) {
                for (let x = 0; x < mazeSize; x++) {
                    if (maze[y][x] === 1) {
                        ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                    }
                }
            }
            
            // Рисуем выход
            ctx.fillStyle = '#ffaa00';
            ctx.fillRect(exit.x * cellWidth, exit.y * cellHeight, cellWidth, cellHeight);
            
            // Рисуем игрока
            ctx.fillStyle = '#f72585';
            ctx.beginPath();
            ctx.arc(
                (player.x + 0.5) * cellWidth,
                (player.y + 0.5) * cellHeight,
                Math.min(cellWidth, cellHeight) / 2.5,
                0,
                Math.PI * 2
            );
            ctx.fill();
        }
        
        function movePlayer(dx, dy) {
            const newX = player.x + dx;
            const newY = player.y + dy;
            
            // Проверяем, можно ли переместиться в новую позицию
            if (newX >= 0 && newX < mazeSize && newY >= 0 && newY < mazeSize && maze[newY][newX] === 0) {
                player.x = newX;
                player.y = newY;
                drawMaze();
                
                // Проверяем, дошел ли игрок до выхода
                if (player.x === exit.x && player.y === exit.y) {
                    levelComplete();
                }
            }
        }
        
        function handleTouchStart(event) {
            // Запоминаем начальную позицию касания
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
            event.preventDefault();
        }
        
        function handleTouchMove(event) {
            if (!touchStartX || !touchStartY) return;
            
            const touchEndX = event.touches[0].clientX;
            const touchEndY = event.touches[0].clientY;
            
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;
            
            // Определяем направление свайпа
            if (Math.abs(dx) > Math.abs(dy)) {
                // Горизонтальный свайп
                if (dx > 0) movePlayer(1, 0);  // Вправо
                else movePlayer(-1, 0);         // Влево
            } else {
                // Вертикальный свайп
                if (dy > 0) movePlayer(0, 1);   // Вниз
                else movePlayer(0, -1);         // Вверх
            }
            
            // Сбрасываем начальные координаты
            touchStartX = null;
            touchStartY = null;
            
            event.preventDefault();
        }
        
        function levelComplete() {
            clearInterval(timerInterval);
            
            document.getElementById('complete-time').textContent = gameTime;
            document.getElementById('level-complete-screen').classList.remove('hidden');
        }
        
        function nextLevel() {
            currentLevel++;
            startGame();
        }
        
        function showMenu() {
            clearInterval(timerInterval);
            document.getElementById('level-complete-screen').classList.add('hidden');
            document.getElementById('start-screen').classList.remove('hidden');
        }
        
        // Вспомогательные функции
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        // Запуск игры при загрузке страницы
        window.onload = init;
    </script>
</body>
</html>
